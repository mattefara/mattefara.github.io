"use strict";(self.webpackChunkhomelab_blog=self.webpackChunkhomelab_blog||[]).push([[894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"Wave","metadata":{"permalink":"/blog/Wave","source":"@site/blog/2024-06-07-wave/index.md","title":"Reloading credentials in legacy applications with Vault and Wave","description":"This article discusses the automation of credential rotation with Vault for applications that do not natively support it. The complete repository can be found here.","date":"2024-06-07T00:00:00.000Z","tags":[{"label":"kubernetes","permalink":"/blog/tags/kubernetes"},{"label":"eso","permalink":"/blog/tags/eso"},{"label":"vault","permalink":"/blog/tags/vault"},{"label":"wave","permalink":"/blog/tags/wave"}],"readingTime":5.64,"hasTruncateMarker":false,"authors":[{"name":"Matteo Faraci","title":"Site maintainer","url":"https://github.com/mattefara","imageURL":"https://github.com/mattefara.png","key":"matteo"}],"frontMatter":{"slug":"Wave","title":"Reloading credentials in legacy applications with Vault and Wave","authors":["matteo"],"tags":["kubernetes","eso","vault","wave"]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"This article discusses the automation of credential rotation with Vault for applications that do not natively support it. The complete repository can be found [here](https://github.com/mattefara/k8s-wave-test). \\n\\n## Introduction to Tools\\n\\n### Vault\\n\\nOne of the appealing features of Vault is the [dynamic secrets](https://developer.hashicorp.com/vault/tutorials/db-credentials/database-secrets). \\nThese types of credentials are automatically rotated after a fixed period, such as database credentials.\\n\\nTypically, applications must support this feature, which means that there is often an integration with Vault at the application layer. \\nIn other words, the application itself must support Vault. \\n\\nVault offers another type of integration with init containers and sidecars.\\nSpecifically, with the sidecar, the application must reload its configuration after the credential rotation, but this feature is not always supported.\\n\\n### Wave\\n\\n`Wave monitors Deployments, StatefulSets, and DaemonSets within a Kubernetes cluster and ensures that their Pods always have up-to-date configuration.`\\nWave introduces itself with this statement and can be useful in this case.\\nWhen a configuration changes, Wave performs a rollout strategy so that the application can use new configurations.\\n\\nAt this point, what is missing is something that can update Secrets with the values in Vault, keeping them synchronized.\\n\\n### External Secret Operator (ESO)\\n\\nThe External Secret Operator is a tool that monitors and synchronizes Kubernetes Secrets with others from an external source.\\nThis tool supports a variety of external sources like AWS, CPG, Vault, etc. \\nA list of providers can be found [here](https://external-secrets.io/latest/provider/hashicorp-vault/).\\n\\nThis tool adds the missing piece for full integration.\\nIt is responsible for reading the credentials at time intervals from Vault and writing them as a Secret in Kubernetes.\\n\\nTo summarize: credentials can be generated from Vault and expire after a fixed amount of time, ESO requests new credentials from Vault and saves them as Secrets in Kubernetes, Wave watches these secrets and updates the Deployments using them.\\n\\n## Hands-On\\n\\n### Vault Setup\\n\\n#### Installation\\nVault can be installed using the [Helm Chart](https://developer.hashicorp.com/vault/docs/platform/k8s/helm#using-the-helm-chart).\\nFor demonstration purposes, raft is disabled, using a single instance with storage as a file.\\n```yaml\\nserver:\\n  standalone:\\n    config: |\\n      ui = true\\n\\n      listener \\"tcp\\" {\\n        tls_disable = 1\\n        address = \\"[::]:8200\\"\\n        cluster_address = \\"[::]:8201\\"\\n        # Enable unauthenticated metrics access (necessary for Prometheus Operator)\\n        telemetry {\\n          unauthenticated_metrics_access = \\"true\\"\\n        }\\n      }\\n      storage \\"file\\" {\\n        path = \\"/vault/data\\"\\n      }\\n\\n      # Example configuration for enabling Prometheus metrics in your config.\\n      telemetry {\\n        prometheus_retention_time = \\"1h\\"\\n        disable_hostname = true\\n      }\\n```\\nWith this configuration, the application exposes metrics that can be scraped with Prometheus.\\n\\nAlso, TLS is disabled because the work can be left to services like Istio, but in this case, it is only for demonstration purposes. \\n\\n#### Kubernetes Integration\\nKubernetes Service Accounts can be authenticated with Vault, so they can generate database credentials with an API call. The full configuration can be found [here](https://developer.hashicorp.com/vault/docs/auth/kubernetes#configuration).\\n\\nIn this demonstration, long-lived tokens described [here](https://developer.hashicorp.com/vault/docs/auth/kubernetes#continue-using-long-lived-tokens) will be used.\\n\\n#### Database Secret Engine\\nVault supports different plugins for database credential creation and rotation, and the list can be found [here](https://developer.hashicorp.com/vault/docs/secrets/databases#database-capabilities). \\nIn this case, the [Postgres database secret engine](https://developer.hashicorp.com/vault/docs/secrets/databases/postgresql) is used.\\n\\n### External Secret Operator Setup\\n\\nLike Vault, ESO can be installed using a [Helm Chart](https://external-secrets.io/latest/introduction/getting-started/).\\nIn this case, the configuration stored in the `values.yaml` file is the default.\\n\\n#### Connecting to Vault and Storing Secrets\\n\\nFirstly, a Kubernetes Service Account token is needed for the demonstration.\\nThe service account is called Vault, and is responsible for the authentication with Vault for the generation of the dynamic secret.\\n```yml\\napiVersion: v1\\nkind: ServiceAccount\\nmetadata:\\n  name: vault\\n---\\napiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: vault-k8s-auth-secret\\n  annotations:\\n    kubernetes.io/service-account.name: vault\\ntype: kubernetes.io/service-account-token\\n```\\nAfter the service account, it\'s time to instruct ESO to generate secrets from Vault.\\nThis is possible with the CRD `VaultDynamicSecret`, which defines how ESO should call the API of Vault.\\nIn this resource, the role to use inside Vault during the generation and the Service Account requesting it are defined.\\nFrom the Vault API specifications, the API call must be made with the `GET` method.\\n\\nThe `ExternalSecret` resource, on the other hand, is used for storing the secret inside Kubernetes.\\nFrom the parameters, it is possible to specify the `generatorRef`, which is a link to the `VaultDynamicSecret` used above.\\n\\n```yml\\napiVersion: generators.external-secrets.io/v1alpha1\\nkind: VaultDynamicSecret\\nmetadata:\\n  name: \\"pg-secret\\"\\nspec:\\n  path: \\"/database/creds/readonly\\"\\n  method: \\"GET\\"\\n  provider:\\n    server: \\"http://vault.vault.svc.cluster.local:8200\\"\\n    auth:\\n      kubernetes:\\n        mountPath: \\"kubernetes\\"\\n        role: \\"readonly\\"\\n        serviceAccountRef:\\n          name: \\"vault\\"\\n---\\napiVersion: external-secrets.io/v1beta1\\nkind: ExternalSecret\\nmetadata:\\n  name: \\"pg-secret-com\\"\\nspec:\\n  refreshInterval: \\"2m\\"\\n  target:\\n    name: pg-secret-com\\n  dataFrom:\\n  - sourceRef:\\n      generatorRef:\\n        apiVersion: generators.external-secrets.io/v1alpha1\\n        kind: VaultDynamicSecret\\n        name: \\"pg-secret\\"\\n```\\nAfter these steps, a new secret, called `pg-secret-com`, will be generated and it will have two keys called `username` and `password`.\\nThe secret will be synchronized every `refreshInterval` time and the Kubernetes secret will be overridden.\\n\\n### Wave Setup\\n\\nLike the other applications, Wave can be installed using its [Helm Chart](https://github.com/wave-k8s/wave) and no further configuration is needed.\\n\\n#### Watching for Config Updates\\nTo instruct Wave to watch for configuration is straightforward.\\nThe only required annotation is: `wave.pusher.com/update-on-config-change: \\"true\\"`\\nFrom now on, the Deployment will be watched and restarted every time the Secret `pg-secret-com` updates.\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  ...\\n  annotations:\\n    wave.pusher.com/update-on-config-change: \\"true\\"\\nspec:\\n  ...\\n  template:\\n    ...\\n    spec:\\n      containers:\\n      - name: demo\\n        ...\\n        env:\\n        - ...\\n        - name: DB_USER\\n          valueFrom:\\n            secretKeyRef:\\n              name: pg-secret-com\\n              key: username\\n        - name: DB_PASSWORD\\n          valueFrom:\\n            secretKeyRef:\\n              name: pg-secret-com\\n              key: password\\n```\\n## Load Testing with Locust\\nThe configuration must be validated.\\nFor this reason, it will be load tested using [Locust](https://locust.io/).\\n\\nLocust is a load testing tool that is really simple to start with.\\nThe configuration is written in Python.\\n\\n```python\\nfrom locust import FastHttpUser, between, task\\n\\n\\nclass WebsiteUser(FastHttpUser):\\n\\n    @task\\n    def index(self):\\n        self.client.get(\\"/\\")\\n```\\nIn this case, performance is not important but failures are.\\n\\n![Locust result](./images/locust.png)\\n\\nIn this case, after three deployments caused by Wave, the request failures are at 0%.\\nEvery time a new deployment is started, new Vault credentials are generated while the others do not expire immediately.\\n\\nThe API called is really simple, it just tests a database connection with every request.\\n\\n```golang\\nhttp.HandleFunc(\\"/\\", func(w http.ResponseWriter, r *http.Request) {\\n  rows, err := db.Queryx(\\"SELECT pg_sleep($1)\\", pg_sleep)\\n  if err != nil {\\n          log.Panic(err)\\n  }\\n  defer rows.Close()\\n\\n  fmt.Fprintf(w, \\"Ok\\")\\n})\\n```\\n\\n## Conclusions\\n\\nUsing this method, it is possible to integrate dynamic secrets using Vault with applications that do not support it. This increases complexity because two new tools, ESO and Wave, come into play. However, the maintenance appears to be relatively simple.\\n\\nThe test conducted with Locust is not a performance test; it merely checks if the solution works. The standard deployment uses three replicas for the tested application, showing good results with no connection errors.\\n\\nIf the number of replicas decreases, there are some connection errors, but they are less than 1% during the load of 1000 RPS. Nevertheless, the application attempts to shut down gracefully, terminating connections before closing down."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/2024-02-22-welcome/index.md","title":"Welcome","description":"This marks the beginning of my journey through the exploration of new technologies. I\'m an Italian guy passionate about technology and eager to explore new things.","date":"2024-02-22T00:00:00.000Z","tags":[{"label":"docusaurus","permalink":"/blog/tags/docusaurus"}],"readingTime":0.72,"hasTruncateMarker":false,"authors":[{"name":"Matteo Faraci","title":"Site maintainer","url":"https://github.com/mattefara","imageURL":"https://github.com/mattefara.png","key":"matteo"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["matteo"],"tags":["docusaurus"]},"unlisted":false,"prevItem":{"title":"Reloading credentials in legacy applications with Vault and Wave","permalink":"/blog/Wave"}},"content":"This marks the beginning of my journey through the exploration of new technologies. I\'m an Italian guy passionate about technology and eager to explore new things.\\n\\nWhenever I come across something I find interesting, I will try it out and share my thoughts here.\\n\\nI hope this project can help me grow both professionally and mentally, allowing me to expand my knowledge.\\n\\n## Why not Medium?\\n\\nI have nothing against Medium or similar sites. However, I prefer to maintain my own site so that I have full control over it. For now, I\'m using Github Pages to avoid managing a server, but we\'ll see what the future holds.\\n\\nHaving a website can help me better track my achievements and accomplishments while also improving my English skills. Currently, everything is powered by [Docusaurus](https://docusaurus.io/).\\n\\nThis is my first time doing something like this, and I\'m excited!"}]}')}}]);